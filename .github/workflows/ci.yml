name: Rust CI

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'CODEOWNERS'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'CODEOWNERS'

permissions:
  contents: read
  actions: write
  packages: write
  # Needed for SLSA provenance generation
  id-token: write

env:
  NEW_RELIC_INSERT_KEY: ${{ secrets.NEW_RELIC_INSERT_KEY }}
  NEW_RELIC_ACCOUNT_ID: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
  REPOSITORY: ${{ github.repository }}
  WORKFLOW: ${{ github.workflow }}
  JOB: ${{ github.job }}
  RUN_ID: ${{ github.run_id }}
  GITHUB_EVENT_PATH: ${{ github.event_path }}
  GITHUB_SHA: ${{ github.sha }}

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache Cargo build artifacts
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Build
        uses: ./.github/actions/time-and-report
        with:
          step: "build"
          command: "cargo build --verbose"

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache Cargo build artifacts
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Run Tests
        uses: ./.github/actions/time-and-report
        with:
          step: "run_tests"
          command: "cargo test --verbose"

  clippy:
    name: Run Clippy
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache Cargo build artifacts
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Run Clippy
        uses: ./.github/actions/time-and-report
        with:
          step: "run_clippy"
          command: "cargo clippy --all-targets --all-features -- -D warnings"

  docs:
    name: Generate Documentation
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Generate Documentation
        uses: ./.github/actions/time-and-report
        with:
          step: "generate_documentation"
          command: "cargo doc --no-deps --document-private-items"

      - name: Upload Documentation Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docs
          path: target/doc

  docker:
    name: Build Multi-Platform Docker Image
    runs-on: ubuntu-latest
    needs: [build, test, clippy]
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image: ${{ steps.build.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: ./docker-cache
          key: ${{ runner.os }}-docker-cache-${{ hashFiles('docker-bake.hcl') }}

      - name: Build and Push Docker Image
        id: build
        uses: ./.github/actions/time-and-report
        with:
          step: "build_and_push_docker_image"
          command: |
            set -euo pipefail
            echo "Building and pushing Docker image..."
            docker buildx bake --push --metadata-file /tmp/metadata.json
            
            echo "=== Metadata file contents ==="
            cat /tmp/metadata.json
            echo "=========================="
            
            # Try multiple ways to extract the digest
            digest=""
            
            # Method 1: Direct key access
            digest=$(jq -r '.["tarnished-api"]["containerimage.digest"] // empty' /tmp/metadata.json)
            echo "Method 1 digest: '$digest'"
            
            # Method 2: Iterate through entries
            if [ -z "$digest" ] || [ "$digest" = "null" ]; then
              digest=$(jq -r 'to_entries[] | select(.key == "tarnished-api") | .value["containerimage.digest"] // empty' /tmp/metadata.json)
              echo "Method 2 digest: '$digest'"
            fi
            
            # Method 3: Find any containerimage.digest
            if [ -z "$digest" ] || [ "$digest" = "null" ]; then
              digest=$(jq -r '.[] | select(has("containerimage.digest")) | .["containerimage.digest"] // empty' /tmp/metadata.json)
              echo "Method 3 digest: '$digest'"
            fi
            
            # Method 4: Find digest in any nested structure
            if [ -z "$digest" ] || [ "$digest" = "null" ]; then
              digest=$(jq -r '.. | objects | select(has("containerimage.digest")) | .["containerimage.digest"] // empty' /tmp/metadata.json | head -1)
              echo "Method 4 digest: '$digest'"
            fi
            
            if [ -z "$digest" ] || [ "$digest" = "null" ]; then
              echo "ERROR: Failed to extract digest from metadata"
              echo "Full metadata structure:"
              jq . /tmp/metadata.json
              echo "Available keys:"
              jq -r 'keys[]' /tmp/metadata.json
              exit 1
            fi
            
            echo "Final digest: $digest"
            echo "digest=$digest" >> "$GITHUB_OUTPUT"
            echo "image=ghcr.io/markcoleman/tarnished-api" >> "$GITHUB_OUTPUT"

  # Build binary for SLSA provenance generation
  build-binary:
    name: Build Binary for SLSA
    runs-on: ubuntu-latest
    needs: [build, test, clippy]
    outputs:
      binary-hash: ${{ steps.binary-hash.outputs.hash }}
      binary-name: ${{ steps.binary-hash.outputs.name }}
      subjects-base64: ${{ steps.binary-hash.outputs.subjects-base64 }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache Cargo build artifacts
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Build Release Binary
        run: cargo build --release

      - name: Generate binary hash
        id: binary-hash
        run: |
          set -euo pipefail
          BINARY_NAME="tarnished-api"
          BINARY_PATH="target/release/$BINARY_NAME"
          
          echo "Checking for binary at: $BINARY_PATH"
          if [ -f "$BINARY_PATH" ]; then
            HASH=$(sha256sum "$BINARY_PATH" | cut -d' ' -f1)
            echo "hash=$HASH" >> "$GITHUB_OUTPUT"
            echo "name=$BINARY_NAME" >> "$GITHUB_OUTPUT"
            echo "Binary hash generated: $HASH"
            
            # Generate base64-encoded subjects for SLSA
            SUBJECTS_JSON='[{"name":"'$BINARY_NAME'","digest":{"sha256":"'$HASH'"}}]'
            echo "Generated subjects JSON: $SUBJECTS_JSON"
            
            # Validate JSON before encoding
            echo "$SUBJECTS_JSON" | jq . > /dev/null || {
              echo "ERROR: Invalid JSON generated"
              exit 1
            }
            
            SUBJECTS_B64=$(echo -n "$SUBJECTS_JSON" | base64 -w 0)
            echo "Base64 subjects (first 50 chars): ${SUBJECTS_B64:0:50}..."
            echo "subjects-base64=$SUBJECTS_B64" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: Binary not found at $BINARY_PATH"
            echo "Contents of target/release/:"
            ls -la target/release/ || echo "Release directory not found"
            echo "Contents of target/:"
            ls -la target/ || echo "Target directory not found"
            exit 1
          fi

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: tarnished-api-binary
          path: target/release/tarnished-api
          retention-days: 5

  # Generate SLSA provenance for binary (manual implementation for debugging)
  binary-provenance:
    name: Generate Binary SLSA Provenance
    runs-on: ubuntu-latest
    needs: [build-binary]
    permissions:
      actions: read
      id-token: write
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Decode and validate subjects
        id: decode-subjects
        run: |
          set -euo pipefail
          echo "=== DEBUGGING BINARY PROVENANCE ==="
          echo "Decoding base64 subjects..."
          SUBJECTS_B64="${{ needs.build-binary.outputs.subjects-base64 }}"
          echo "Base64 input (first 100 chars): ${SUBJECTS_B64:0:100}..."
          echo "Base64 input length: ${#SUBJECTS_B64}"
          
          if [ -z "$SUBJECTS_B64" ]; then
            echo "ERROR: No base64 subjects provided"
            echo "Available build-binary outputs:"
            echo "binary-hash: ${{ needs.build-binary.outputs.binary-hash }}"
            echo "binary-name: ${{ needs.build-binary.outputs.binary-name }}"
            echo "subjects-base64: ${{ needs.build-binary.outputs.subjects-base64 }}"
            exit 1
          fi
          
          SUBJECTS_JSON=$(echo "$SUBJECTS_B64" | base64 -d)
          echo "Decoded subjects JSON: $SUBJECTS_JSON"
          
          # Validate JSON structure
          echo "$SUBJECTS_JSON" | jq . > /dev/null || {
            echo "ERROR: Invalid JSON in subjects"
            echo "Raw base64: $SUBJECTS_B64"
            echo "Raw decoded: $SUBJECTS_JSON"
            exit 1
          }
          
          # Extract name and hash for verification
          NAME=$(echo "$SUBJECTS_JSON" | jq -r '.[0].name // empty')
          HASH=$(echo "$SUBJECTS_JSON" | jq -r '.[0].digest.sha256 // empty')
          
          echo "Extracted name: '$NAME'"
          echo "Extracted hash: '$HASH'"
          
          if [ -z "$NAME" ] || [ -z "$HASH" ]; then
            echo "ERROR: Missing name or hash in subjects"
            echo "Full JSON structure:"
            echo "$SUBJECTS_JSON" | jq .
            exit 1
          fi
          
          echo "subjects-json=$SUBJECTS_JSON" >> "$GITHUB_OUTPUT"
          echo "binary-name=$NAME" >> "$GITHUB_OUTPUT"
          echo "binary-hash=$HASH" >> "$GITHUB_OUTPUT"
      
      - name: Generate basic SLSA provenance (simplified for debugging)
        id: generate-provenance
        run: |
          set -euo pipefail
          echo "=== GENERATING BASIC SLSA PROVENANCE ==="
          
          SUBJECTS_JSON='${{ steps.decode-subjects.outputs.subjects-json }}'
          BINARY_NAME='${{ steps.decode-subjects.outputs.binary-name }}'
          BINARY_HASH='${{ steps.decode-subjects.outputs.binary-hash }}'
          
          echo "Binary: $BINARY_NAME"
          echo "Hash: $BINARY_HASH"
          
          # Create a basic SLSA provenance structure
          cat > provenance.json << EOF
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://slsa.dev/provenance/v0.2",
            "subject": $SUBJECTS_JSON,
            "predicate": {
              "builder": {
                "id": "https://github.com/actions/runner"
              },
              "buildType": "https://github.com/actions/runner",
              "invocation": {
                "configSource": {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  },
                  "entryPoint": ".github/workflows/ci.yml"
                }
              },
              "metadata": {
                "buildInvocationId": "${{ github.run_id }}",
                "buildStartedOn": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
                "completeness": {
                  "parameters": false,
                  "environment": false,
                  "materials": false
                },
                "reproducible": false
              },
              "materials": [
                {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              ]
            }
          }
          EOF
          
          echo "Generated basic provenance:"
          jq . provenance.json
          
          # Validate the JSON
          jq . provenance.json > /dev/null || {
            echo "ERROR: Generated provenance is not valid JSON"
            exit 1
          }
          
          echo "✅ Basic SLSA provenance generated successfully"
          echo "Provenance file size: $(wc -c < provenance.json) bytes"
          
      - name: Upload provenance artifact
        uses: actions/upload-artifact@v4
        with:
          name: binary-provenance
          path: provenance.json
          retention-days: 5

  # Generate SLSA provenance for container (manual implementation for debugging)  
  container-provenance:
    name: Generate Container SLSA Provenance
    runs-on: ubuntu-latest
    needs: [docker]
    permissions:
      actions: read
      id-token: write
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate container inputs
        id: validate-inputs
        run: |
          set -euo pipefail
          echo "=== DEBUGGING CONTAINER PROVENANCE ==="
          echo "Validating container inputs..."
          
          IMAGE="${{ needs.docker.outputs.image }}"
          DIGEST="${{ needs.docker.outputs.digest }}"
          
          echo "Image: '$IMAGE'"
          echo "Digest: '$DIGEST'"
          echo "Digest length: ${#DIGEST}"
          
          if [ -z "$IMAGE" ] || [ -z "$DIGEST" ]; then
            echo "ERROR: Missing image or digest"
            echo "Available docker job outputs:"
            echo "IMAGE: $IMAGE"
            echo "DIGEST: $DIGEST"
            echo "Checking if docker job succeeded..."
            exit 1
          fi
          
          # Validate digest format (should start with sha256:)
          if [[ ! "$DIGEST" =~ ^sha256:[a-fA-F0-9]{64}$ ]]; then
            echo "WARNING: Digest format may be unusual. Expected sha256:..., got: $DIGEST"
            # Don't fail here, continue for debugging
          fi
          
          echo "✅ Container inputs validated"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"
          
      - name: Generate basic container SLSA provenance (simplified for debugging)
        run: |
          set -euo pipefail
          echo "=== GENERATING BASIC CONTAINER SLSA PROVENANCE ==="
          
          IMAGE="${{ steps.validate-inputs.outputs.image }}"
          DIGEST="${{ steps.validate-inputs.outputs.digest }}"
          
          echo "Container: $IMAGE@$DIGEST"
          
          # Extract SHA256 hash from digest (remove sha256: prefix if present)
          SHA256_HASH="${DIGEST#sha256:}"
          echo "SHA256 hash: $SHA256_HASH"
          
          # Create subjects JSON for container
          SUBJECTS_JSON='[{"name":"'$IMAGE'","digest":{"sha256":"'$SHA256_HASH'"}}]'
          echo "Container subjects: $SUBJECTS_JSON"
          
          # Validate JSON
          echo "$SUBJECTS_JSON" | jq . > /dev/null || {
            echo "ERROR: Invalid container subjects JSON"
            echo "Raw subjects: $SUBJECTS_JSON"
            exit 1
          }
          
          # Create a basic SLSA provenance structure for container
          cat > container-provenance.json << EOF
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://slsa.dev/provenance/v0.2",
            "subject": $SUBJECTS_JSON,
            "predicate": {
              "builder": {
                "id": "https://github.com/actions/runner"
              },
              "buildType": "https://github.com/actions/runner/docker",
              "invocation": {
                "configSource": {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  },
                  "entryPoint": ".github/workflows/ci.yml"
                }
              },
              "metadata": {
                "buildInvocationId": "${{ github.run_id }}",
                "buildStartedOn": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
                "completeness": {
                  "parameters": false,
                  "environment": false,
                  "materials": false
                },
                "reproducible": false
              },
              "materials": [
                {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              ]
            }
          }
          EOF
          
          echo "Generated basic container provenance:"
          jq . container-provenance.json
          
          # Validate the JSON
          jq . container-provenance.json > /dev/null || {
            echo "ERROR: Generated container provenance is not valid JSON"
            exit 1
          }
          
          echo "✅ Basic container SLSA provenance generated successfully"
          echo "Provenance file size: $(wc -c < container-provenance.json) bytes"
          
      - name: Upload container provenance artifact
        uses: actions/upload-artifact@v4
        with:
          name: container-provenance
          path: container-provenance.json
          retention-days: 5
