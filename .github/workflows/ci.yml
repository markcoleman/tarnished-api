name: Rust CI

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'CODEOWNERS'
      - 'LICENCE'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'CODEOWNERS'
      - 'LICENCE'

permissions:
  contents: read
  actions: write
  packages: write

env:
  NEW_RELIC_INSERT_KEY: ${{ secrets.NEW_RELIC_INSERT_KEY }}
  NEW_RELIC_ACCOUNT_ID: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
  REPOSITORY: ${{ github.repository }}
  WORKFLOW: ${{ github.workflow }}
  JOB: ${{ github.job }}
  RUN_ID: ${{ github.run_id }}
  GITHUB_EVENT_PATH: ${{ github.event_path }}
  GITHUB_SHA: ${{ github.sha }}
  # Enable incremental compilation globally
  CARGO_INCREMENTAL: 1
  CARGO_NET_RETRY: 10
  # Use GitHub Actions cache for sccache
  SCCACHE_GHA_ENABLED: "true"
  RUSTC_WRAPPER: "sccache"

jobs:
  # Check what files changed to conditionally skip expensive jobs
  changes:
    runs-on: ubuntu-latest
    outputs:
      docs-only: ${{ steps.changes.outputs.docs-only }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for documentation-only changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check what files changed
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
            echo "Changed files: $CHANGED_FILES"
            
            # Check if only documentation files changed
            if echo "$CHANGED_FILES" | grep -qvE '(\.(md|txt|rst)|^(docs/|LICENCE|CODEOWNERS|README|LICENSE))'; then
              echo "docs-only=false" >> $GITHUB_OUTPUT
            else
              echo "docs-only=true" >> $GITHUB_OUTPUT
            fi
          else
            # For pushes, always run all jobs
            echo "docs-only=false" >> $GITHUB_OUTPUT
          fi

  # Use a matrix strategy to run all quality checks in parallel
  quality:
    name: ${{ matrix.job }}
    runs-on: ubuntu-latest
    needs: changes
    # Skip for docs-only changes on PRs
    if: needs.changes.outputs.docs-only != 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - job: "Build"
            step: "build"
            command: "cargo build --verbose"
          - job: "Test"
            step: "run_tests"
            command: "cargo test --verbose"
          - job: "Clippy"
            step: "run_clippy"
            command: "cargo clippy --all-targets --all-features -- -D warnings"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache target directory
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-target-${{ matrix.step }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-target-${{ matrix.step }}-
            ${{ runner.os }}-target-

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: ${{ matrix.job }}
        uses: ./.github/actions/time-and-report
        with:
          step: ${{ matrix.step }}
          command: ${{ matrix.command }}

  docs:
    name: Generate Documentation
    runs-on: ubuntu-latest
    needs: changes
    # Always run docs job since it can benefit from doc changes
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache target directory
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-target-docs-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-target-docs-
            ${{ runner.os }}-target-

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Generate Documentation
        uses: ./.github/actions/time-and-report
        with:
          step: "generate_documentation"
          command: "cargo doc --no-deps --document-private-items"

      - name: Upload Documentation Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docs
          path: target/doc

  docker:
    name: Build Multi-Platform Docker Image
    runs-on: ubuntu-latest
    # Only need test to pass - build and clippy are checked independently
    needs: [changes, quality]
    # Skip for docs-only changes on PRs
    if: needs.changes.outputs.docs-only != 'true'
    permissions:
      contents: read
      packages: write
      id-token: write  # Required for OIDC token generation for cosign
      attestations: write  # Required for attestations
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # SBOM Performance Optimization: Cache binaries to save 30-60s per run
      # Install syft for SBOM generation (with caching)
      - name: Cache syft binary
        id: cache-syft
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/syft
          key: syft-${{ runner.os }}-v1.19.0

      - name: Install syft
        if: steps.cache-syft.outputs.cache-hit != 'true'
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin v1.19.0

      # Install cosign for signing (with caching)
      - name: Cache cosign binary
        id: cache-cosign
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/cosign
          key: cosign-${{ runner.os }}-v2.4.1

      - name: Install cosign
        if: steps.cache-cosign.outputs.cache-hit != 'true'
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.4.1'

      # Log in to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: ./docker-cache
          key: ${{ runner.os }}-docker-cache-${{ hashFiles('docker-bake.hcl') }}

      # SBOM Performance Optimization: Cache operations to save 1-3 minutes per run
      # Cache syft operations to speed up SBOM generation
      - name: Cache syft operations
        uses: actions/cache@v4
        with:
          path: /tmp/syft-cache
          key: ${{ runner.os }}-syft-cache-${{ hashFiles('**/Cargo.lock', 'Dockerfile') }}

      # SBOM Performance Optimization: Build locally first to avoid registry pull (saves 2-5 minutes)
      - name: Build Docker Image Locally
        uses: ./.github/actions/time-and-report
        with:
          step: "build_docker_image_locally"
          command: "docker buildx bake --load"

      # Generate SBOM from the local built image (much faster than pulling from registry)
      - name: Generate SBOM
        uses: ./.github/actions/time-and-report
        with:
          step: "generate_sbom"
          command: "syft ghcr.io/markcoleman/tarnished-api:latest -o cyclonedx-json=tarnished-api-sbom.json -o spdx-json=tarnished-api-sbom.spdx.json"
        env:
          SYFT_CACHE_DIR: /tmp/syft-cache

      # Push the Docker image after SBOM generation
      - name: Push Docker Image
        uses: ./.github/actions/time-and-report
        with:
          step: "push_docker_image"
          command: "docker buildx bake --push"

      # Sign the SBOM with cosign
      - name: Sign SBOM
        uses: ./.github/actions/time-and-report
        with:
          step: "sign_sbom"
          command: "cosign sign-blob --yes tarnished-api-sbom.json --output-signature=tarnished-api-sbom.json.sig --output-certificate=tarnished-api-sbom.json.pem"

      # Create and sign SBOM attestation (this is the main step)
      - name: Create SBOM attestation
        uses: ./.github/actions/time-and-report
        with:
          step: "create_sbom_attestation"
          command: "cosign attest --yes --predicate tarnished-api-sbom.json --type cyclonedx ghcr.io/markcoleman/tarnished-api:latest"

      # Upload SBOMs as artifacts for centralized access (before verification)
      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-artifacts
          path: |
            tarnished-api-sbom.json
            tarnished-api-sbom.spdx.json
            tarnished-api-sbom.json.sig
            tarnished-api-sbom.json.pem

  # SBOM Performance Optimization: Move verification to parallel job (saves 5-10 minutes)
  # Move verification to a separate job that runs in parallel
  verify:
    name: Verify SBOM Signatures
    runs-on: ubuntu-latest
    needs: docker
    # Only run verification on main branch or if manually triggered
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: read
      id-token: write
    env:
      NEW_RELIC_INSERT_KEY: ${{ secrets.NEW_RELIC_INSERT_KEY }}
      NEW_RELIC_ACCOUNT_ID: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
      REPOSITORY: ${{ github.repository }}
      WORKFLOW: ${{ github.workflow }}
      JOB: ${{ github.job }}
      RUN_ID: ${{ github.run_id }}
      GITHUB_EVENT_PATH: ${{ github.event_path }}
      GITHUB_SHA: ${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.4.1'

      - name: Download SBOM artifacts
        uses: actions/download-artifact@v4
        with:
          name: sbom-artifacts

      # Verify the SBOM signature (as a validation step)
      - name: Verify SBOM signature
        uses: ./.github/actions/time-and-report
        with:
          step: "verify_sbom_signature"
          command: "cosign verify-blob --signature tarnished-api-sbom.json.sig --certificate tarnished-api-sbom.json.pem --certificate-identity-regexp='https://github.com/markcoleman/tarnished-api/.*' --certificate-oidc-issuer=https://token.actions.githubusercontent.com tarnished-api-sbom.json"

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Verify the SBOM attestation attached to the image
      - name: Verify SBOM attestation
        uses: ./.github/actions/time-and-report
        with:
          step: "verify_sbom_attestation"
          command: "cosign verify-attestation --type=cyclonedx --certificate-identity-regexp='https://github.com/markcoleman/tarnished-api/.*' --certificate-oidc-issuer=https://token.actions.githubusercontent.com ghcr.io/markcoleman/tarnished-api:latest"

  kubernetes-validation:
    name: Validate Kubernetes Manifests
    runs-on: ubuntu-latest
    # Run independently - doesn't depend on Rust builds
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.33.1'

      - name: Validate YAML syntax
        uses: ./.github/actions/time-and-report
        with:
          step: "validate_yaml_syntax"
          command: |
            pip3 install --quiet PyYAML
            ./scripts/validate-yaml.py

      - name: Validate with kustomize
        uses: ./.github/actions/time-and-report
        with:
          step: "validate_kustomize"
          command: "kustomize build k8s/ > /dev/null && echo 'Kustomize validation successful'"

      - name: Validate Kubernetes manifests
        uses: ./.github/actions/time-and-report
        with:
          step: "validate_k8s_manifests"
          command: |
            # Install kubeconform for offline validation
            curl -L https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz | tar xz
            chmod +x kubeconform
            sudo mv kubeconform /usr/local/bin/
            # Validate Kubernetes manifests (exclude kustomization files)
            kubeconform -summary -verbose -ignore-missing-schemas -skip Kustomization k8s/*.yaml

  deploy-validation:
    name: Deployment Validation Test
    runs-on: ubuntu-latest
    needs: [changes, docker, kubernetes-validation]
    # Only run on main branch and skip for docs-only changes
    if: github.ref == 'refs/heads/main' && needs.changes.outputs.docs-only != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.33.1'

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create kind config file
        run: |
          cat > kind-config.yaml << 'EOF'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            kubeadmConfigPatchesJSON6902:
            - group: kubeadm.k8s.io
              version: v1beta3
              kind: ClusterConfiguration
              patch: |
                - op: add
                  path: /apiServer/certSANs/-
                  value: localhost
          EOF

      - name: Setup kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: tarnished-api-test
          config: kind-config.yaml

      - name: Wait for cluster ready
        uses: ./.github/actions/time-and-report
        with:
          step: "wait_for_cluster"
          command: "kubectl wait --for=condition=Ready nodes --all --timeout=60s"

      - name: Pull Docker image
        uses: ./.github/actions/time-and-report
        with:
          step: "pull_docker_image"
          command: "docker pull ghcr.io/markcoleman/tarnished-api:latest"

      - name: Load Docker image into kind
        uses: ./.github/actions/time-and-report
        with:
          step: "load_docker_image"
          command: "kind load docker-image ghcr.io/markcoleman/tarnished-api:latest --name tarnished-api-test"

      - name: Deploy to kind cluster
        uses: ./.github/actions/time-and-report
        with:
          step: "deploy_to_kind"
          command: "kubectl apply -f k8s/configmap.yaml -f k8s/secret.yaml -f k8s/deployment-ci.yaml -f k8s/service.yaml"

      - name: Show initial pod status
        run: |
          echo "Checking initial deployment status..."
          kubectl get deployments
          kubectl get pods -l app=tarnished-api
          kubectl describe pods -l app=tarnished-api

      - name: Wait for deployment rollout
        uses: ./.github/actions/time-and-report
        with:
          step: "wait_for_rollout"
          command: "kubectl rollout status deployment/tarnished-api --timeout=300s"

      - name: Debug deployment failure
        if: failure()
        run: |
          echo "Deployment failed, gathering debug information..."
          kubectl get deployments
          kubectl get pods -l app=tarnished-api
          kubectl describe deployment tarnished-api
          kubectl describe pods -l app=tarnished-api
          echo "Pod logs:"
          kubectl logs -l app=tarnished-api --tail=50 || echo "No logs available"

      - name: Verify service is reachable
        uses: ./.github/actions/time-and-report
        with:
          step: "verify_service_reachable"
          command: |
            kubectl get pods -l app=tarnished-api
            kubectl get svc tarnished-api-service
            # Port forward in background and test
            kubectl port-forward svc/tarnished-api-service 8080:80 &
            sleep 10
            curl -f http://localhost:8080/api/health || exit 1
            echo "Health check successful"

      - name: Cleanup test cluster
        if: always()
        run: kind delete cluster --name tarnished-api-test
